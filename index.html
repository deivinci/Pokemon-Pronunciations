<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>寶可夢中英日發音｜Pokémon GO 三語搜尋 + 限定招式</title>
    <style>
      :root {
        --bg: #0b1220;
        --card: #111827;
        --muted: #9ca3af;
        --text: #e5e7eb;
        --accent: #60a5fa;
        --chip: #1f2937;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: linear-gradient(180deg, #0b1220 0%, #0f172a 100%);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
          "Noto Sans TC", "Hiragino Sans", "Microsoft JhengHei", sans-serif;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 50;
        background: rgba(10, 15, 28, 0.85);
        backdrop-filter: saturate(150%) blur(8px);
        border-bottom: 1px solid #1f2937;
      }
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 16px;
      }
      .title {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        gap: 6px;
        margin: 8px 0 12px;
      }
      .title h1 {
        margin: 0;
        font-size: 22px;
        font-weight: 800;
      }
      .title h1:nth-child(2) {
        color: #c7d2fe;
      }
      .title h1:nth-child(3) {
        color: #93c5fd;
      }
      .controls {
        display: grid;
        grid-template-columns: 1fr 180px 160px 160px;
        gap: 10px;
      }
      /* 手機版 RWD */
@media (max-width: 768px) {
  .controls {
    grid-template-columns: 1fr; /* 單欄 */
  }
  .controls > * {
    min-width: 100%; /* 每個子元素佔滿一行 */
  }
  .hint {
    font-size: 11px; /* 提示字縮小 */
  }
}
      .search {
        position: relative;
      }
      input,
      select {
        width: 100%;
        border: 1px solid #374151;
        background: #0b1020;
        color: #e5e7eb;
        padding: 10px 12px;
        border-radius: 12px;
        outline: none;
      }
      input::placeholder {
        color: #6b7280;
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
        margin-top: 4px;
      }
      .toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: flex-end;
      }
      .toggle input {
        width: auto;
      }
      main {
        padding: 16px;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
        gap: 14px;
      }
      .card {
        background: var(--card);
        border: 1px solid #1f2937;
        border-radius: 18px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }
      .head {
        display: flex;
        gap: 12px;
        padding: 12px;
        border-bottom: 1px solid #1f2937;
      }
      .sprite {
        width: 88px;
        height: 88px;
        background: #0b1020;
        border-radius: 14px;
        display: grid;
        place-items: center;
        overflow: hidden;
        border: 1px solid #1f2937;
      }
      .sprite img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        image-rendering: pixelated;
      }
      .names {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .name-line {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .tag {
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 999px;
        background: var(--chip);
        border: 1px solid #2a3343;
        color: #93c5fd;
      }
      .nm {
        font-weight: 700;
      }
      .region {
        display: flex;
        gap: 6px;
        align-items: center;
        margin-top: 6px;
      }
      .badge {
        background: #0b1020;
        border: 1px solid #1f2937;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
      }
      .types {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 6px;
      }
      .type {
        font-size: 12px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.15);
      }
      .body {
        padding: 10px 12px;
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .pill {
        display: inline-flex;
        gap: 6px;
        align-items: center;
        padding: 4px 8px;
        background: #0b1020;
        border: 1px solid #1f2937;
        border-radius: 999px;
        font-size: 12px;
        color: #cbd5e1;
      }
      .stat {
        font-family: ui-monospace, monospace;
        font-size: 12px;
        opacity: 0.9;
      }
      details {
        border-top: 1px solid #1f2937;
      }
      summary {
        cursor: pointer;
        list-style: none;
        padding: 10px 12px;
        font-weight: 700;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th,
      td {
        padding: 8px 10px;
        border-top: 1px dashed #293241;
        font-size: 13px;
      }
      th {
        color: #9ca3af;
        text-align: left;
      }
      .loader {
        display: none;
        gap: 8px;
        align-items: center;
        margin-top: 10px;
      }
      .loader.active {
        display: flex;
      }
      .spinner {
        width: 14px;
        height: 14px;
        border: 3px solid #334155;
        border-top-color: #93c5fd;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .tts-ico {
        font-size: 0.9em;
        cursor: pointer;
        margin-left: 4px;
        vertical-align: middle;
        opacity: 0.7;
        user-select: none;
      }
      .tts-ico:hover {
        opacity: 1;
      }
      .tts-ico.playing {
        animation: pulse 0.9s ease-in-out infinite;
        opacity: 1;
      }
      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
        }
      }
      .footer {
        color: #94a3b8;
        font-size: 12px;
        margin-top: 12px;
      }
      .empty {
        opacity: 0.7;
        text-align: center;
        padding: 40px;
      }
      .diag {
        max-width: 1200px;
        margin: 20px auto;
        color: #9ca3af;
        font-size: 12px;
      }
      .diag pre {
        background: #0b1020;
        border: 1px solid #1f2937;
        border-radius: 10px;
        padding: 10px;
        overflow: auto;
      }
      /* 官方風格 type 顏色 */
      .type.Normal {
        background: #a8a77a;
        color: #000;
      }
      .type.Fire {
        background: #ee8130;
      }
      .type.Water {
        background: #6390f0;
      }
      .type.Electric {
        background: #f7d02c;
        color: #000;
      }
      .type.Grass {
        background: #7ac74c;
        color: #000;
      }
      .type.Ice {
        background: #96d9d6;
        color: #000;
      }
      .type.Fighting {
        background: #c22e28;
      }
      .type.Poison {
        background: #a33ea1;
      }
      .type.Ground {
        background: #e2bf65;
        color: #000;
      }
      .type.Flying {
        background: #a98ff3;
      }
      .type.Psychic {
        background: #f95587;
      }
      .type.Bug {
        background: #a6b91a;
        color: #000;
      }
      .type.Rock {
        background: #b6a136;
        color: #000;
      }
      .type.Ghost {
        background: #735797;
      }
      .type.Dragon {
        background: #6f35fc;
      }
      .type.Dark {
        background: #705746;
      }
      .type.Steel {
        background: #b7b7ce;
        color: #000;
      }
      .type.Fairy {
        background: #d685ad;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="container">
        <div class="title">
          <h1>寶可夢中英日發音</h1>
          <h1>Pokémon English, Chinese, and Japanese Pronunciations</h1>
          <h1>ポケモンの英語、中国語、日本語の発音</h1>
        </div>
        <div class="controls">
          <div class="search">
            <input
              id="q"
              placeholder="搜尋寶可夢或招式（中/英/日）e.g. 妙蛙、Bulba、フシギ…"
            />
            <div class="hint">跨地區全域搜尋。名稱 / 別名 / 招式皆可。</div>
          </div>
          <select id="region">
            <option value="all">全部地區</option>
            <option value="kanto">關都 (1–151)</option>
            <option value="johto">城都 (152–251)</option>
            <option value="hoenn">豐緣 (252–386)</option>
            <option value="sinnoh">神奧 (387–493)</option>
            <option value="unova">合眾 (494–649)</option>
            <option value="kalos">卡洛斯 (650–721)</option>
            <option value="alola">阿羅拉 (722–809)</option>
            <option value="galar">伽勒爾 (810–898)</option>
            <option value="paldea">帕底亞 (906–1017)</option>
          </select>
          <select id="sort">
            <option value="id" selected>ID</option>
            <option value="name_en">名稱 (EN)</option>
            <option value="name_zh">名稱 (中文)</option>
            <option value="name_ja">名稱 (日文)</option>
          </select>
          <label class="toggle">
            <input id="expand" type="checkbox" /> 展開招式對照表
          </label>
        </div>
        <div class="loader" id="loader">
          <div class="spinner"></div>
          <div>資料載入中…（PoGoAPI + PokéAPI）</div>
        </div>
      </div>
    </header>

    <main class="container">
      <div id="results" class="grid"></div>
      <div id="empty" class="empty">輸入關鍵字或選擇地區開始瀏覽。</div>
      <div class="footer">
        資料來源：PoGoAPI（Moves/配招）與 PokéAPI（名稱/圖片/屬性）。若外部 API
        不通，將自動切換小型離線資料。
      </div>
    </main>

    <section class="diag container">
      <details>
        <summary>診斷 / 測試</summary>
        <pre id="diag"></pre>
      </details>
    </section>

    <!-- =============== 內嵌：GO 限定招式 JSON（方案B：招式→多個 pokemon_id） =============== -->
    <script id="exclusive-moves" type="application/json">
      {
        "Frenzy Plant": {
          "type": "Grass",
          "category": "charged",
          "names": {
            "en": "Frenzy Plant",
            "zh": "瘋狂植物",
            "ja": "ハードプラント"
          },
          "pokemon_ids": [3, 154, 254, 389, 497, 652, 724, 812, 908]
        },
        "Blast Burn": {
          "type": "Fire",
          "category": "charged",
          "names": {
            "en": "Blast Burn",
            "zh": "爆炸烈焰",
            "ja": "ブラストバーン"
          },
          "pokemon_ids": [6, 157, 257, 392, 500, 655, 727, 815, 911]
        },
        "Hydro Cannon": {
          "type": "Water",
          "category": "charged",
          "names": {
            "en": "Hydro Cannon",
            "zh": "加農水砲",
            "ja": "ハイドロカノン"
          },
          "pokemon_ids": [9, 160, 260, 395, 503, 658, 730, 818, 914]
        },
        "Meteor Mash": {
          "type": "Steel",
          "category": "charged",
          "names": {
            "en": "Meteor Mash",
            "zh": "彗星拳",
            "ja": "コメットパンチ"
          },
          "pokemon_ids": [376]
        },
        "Rock Wrecker": {
          "type": "Rock",
          "category": "charged",
          "names": {
            "en": "Rock Wrecker",
            "zh": "岩石炮",
            "ja": "がんせきほう"
          },
          "pokemon_ids": [464]
        },
        "Smack Down": {
          "type": "Rock",
          "category": "fast",
          "names": { "en": "Smack Down", "zh": "擊落", "ja": "うちおとす" },
          "pokemon_ids": [248, 464]
        },
        "Psystrike": {
          "type": "Psychic",
          "category": "charged",
          "names": {
            "en": "Psystrike",
            "zh": "精神擊破",
            "ja": "サイコブレイク"
          },
          "pokemon_ids": [150]
        },
        "Aeroblast": {
          "type": "Flying",
          "category": "charged",
          "names": {
            "en": "Aeroblast",
            "zh": "氣旋攻擊",
            "ja": "エアロブラスト"
          },
          "pokemon_ids": [249]
        },
        "Sacred Fire": {
          "type": "Fire",
          "category": "charged",
          "names": {
            "en": "Sacred Fire",
            "zh": "神聖之火",
            "ja": "せいなるほのお"
          },
          "pokemon_ids": [250]
        },
        "Sacred Sword": {
          "type": "Fighting",
          "category": "charged",
          "names": {
            "en": "Sacred Sword",
            "zh": "聖劍",
            "ja": "せいなるつるぎ"
          },
          "pokemon_ids": [638, 639, 640, 646]
        },
        "Techno Blast": {
          "type": "Normal",
          "category": "charged",
          "names": {
            "en": "Techno Blast",
            "zh": "高科技光炮",
            "ja": "テクノバスター"
          },
          "pokemon_ids": [649]
        },
        "Doom Desire": {
          "type": "Steel",
          "category": "charged",
          "names": {
            "en": "Doom Desire",
            "zh": "破滅之願",
            "ja": "はめつのねがい"
          },
          "pokemon_ids": [385]
        },
        "Origin Pulse": {
          "type": "Water",
          "category": "charged",
          "names": {
            "en": "Origin Pulse",
            "zh": "根源波動",
            "ja": "こんげんのはどう"
          },
          "pokemon_ids": [382]
        },
        "Precipice Blades": {
          "type": "Ground",
          "category": "charged",
          "names": {
            "en": "Precipice Blades",
            "zh": "斷崖之劍",
            "ja": "だんがいのつるぎ"
          },
          "pokemon_ids": [383]
        },
        "Dragon Ascent": {
          "type": "Flying",
          "category": "charged",
          "names": {
            "en": "Dragon Ascent",
            "zh": "畫龍點睛",
            "ja": "ガリョウテンセイ"
          },
          "pokemon_ids": [384]
        },
        "Roar of Time": {
          "type": "Dragon",
          "category": "charged",
          "names": {
            "en": "Roar of Time",
            "zh": "時光咆哮",
            "ja": "ときのほうこう"
          },
          "pokemon_ids": [483]
        },
        "Spacial Rend": {
          "type": "Dragon",
          "category": "charged",
          "names": {
            "en": "Spacial Rend",
            "zh": "亞空裂斬",
            "ja": "あくうせつだん"
          },
          "pokemon_ids": [484]
        },
        "Shadow Force": {
          "type": "Ghost",
          "category": "charged",
          "names": {
            "en": "Shadow Force",
            "zh": "暗影潛襲",
            "ja": "シャドーダイブ"
          },
          "pokemon_ids": [487]
        },
        "Behemoth Blade": {
          "type": "Steel",
          "category": "charged",
          "names": {
            "en": "Behemoth Blade",
            "zh": "巨獸斬",
            "ja": "きょじゅうざん"
          },
          "pokemon_ids": [888]
        },
        "Behemoth Bash": {
          "type": "Steel",
          "category": "charged",
          "names": {
            "en": "Behemoth Bash",
            "zh": "巨獸彈",
            "ja": "きょじゅうだん"
          },
          "pokemon_ids": [889]
        },
        "Dynamax Cannon": {
          "type": "Dragon",
          "category": "charged",
          "names": {
            "en": "Dynamax Cannon",
            "zh": "極巨炮",
            "ja": "ダイマックスほう"
          },
          "pokemon_ids": [890]
        },

        "Surf": {
          "type": "Water",
          "category": "charged",
          "names": { "en": "Surf", "zh": "衝浪", "ja": "なみのり" },
          "pokemon_ids": [131, 382, 484, 488]
        }
      }
    </script>

    <script>
      (async function () {
        // -------- utilities --------
        const $ = (s, r = document) => r.querySelector(s);
        const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));
        const loader = $("#loader"),
          results = $("#results"),
          empty = $("#empty"),
          diag = $("#diag");
        const qInput = $("#q"),
          regionSel = $("#region"),
          sortSel = $("#sort"),
          expandChk = $("#expand");

        const LANGS = { zh: "zh-TW", en: "en-US", ja: "ja-JP" };

        // region ranges
        const REGIONS = {
          kanto: [1, 151],
          johto: [152, 251],
          hoenn: [252, 386],
          sinnoh: [387, 493],
          unova: [494, 649],
          kalos: [650, 721],
          alola: [722, 809],
          galar: [810, 898],
          paldea: [906, 1017],
        };

        // APIs
        const POGO = {
          fast: "https://pogoapi.net/api/v1/fast_moves.json",
          charged: "https://pogoapi.net/api/v1/charged_moves.json",
          current: "https://pogoapi.net/api/v1/current_pokemon_moves.json",
        };
        const POKE = {
          species: (id) => `https://pokeapi.co/api/v2/pokemon-species/${id}`,
          pokemon: (id) => `https://pokeapi.co/api/v2/pokemon/${id}`,
          move: (slug) => `https://pokeapi.co/api/v2/move/${slug}`,
          art: (id) =>
            `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`,
        };

        // small offline fallback (for sandbox)
        const SPECIES_FALLBACK = {
          1: { en: "Bulbasaur", zh: "妙蛙種子", ja: "フシギダネ" },
          6: { en: "Charizard", zh: "噴火龍", ja: "リザードン" },
          9: { en: "Blastoise", zh: "水箭龜", ja: "カメックス" },
          248: { en: "Tyranitar", zh: "班基拉斯", ja: "バンギラス" },
          376: { en: "Metagross", zh: "巨金怪", ja: "メタグロス" },
          382: { en: "Kyogre", zh: "蓋歐卡", ja: "カイオーガ" },
          383: { en: "Groudon", zh: "固拉多", ja: "グラードン" },
          384: { en: "Rayquaza", zh: "烈空坐", ja: "レックウザ" },
          385: { en: "Jirachi", zh: "基拉祈", ja: "ジラーチ" },
          483: { en: "Dialga", zh: "帝牙盧卡", ja: "ディアルガ" },
          484: { en: "Palkia", zh: "帕路奇亞", ja: "パルキア" },
          487: { en: "Giratina", zh: "騎拉帝納", ja: "ギラティナ" },
        };

        const FALLBACK = {
          fast: [
            {
              name: "Vine Whip",
              duration: 600,
              energy_delta: 8,
              power: 7,
              type: "Grass",
            },
            {
              name: "Smack Down",
              duration: 1200,
              energy_delta: 8,
              power: 16,
              type: "Rock",
            },
          ],
          charged: [
            {
              name: "Frenzy Plant",
              duration: 2400,
              energy_delta: -50,
              power: 100,
              type: "Grass",
            },
            {
              name: "Meteor Mash",
              duration: 2600,
              energy_delta: -50,
              power: 100,
              type: "Steel",
            },
          ],
          current: [
            {
              pokemon_id: 1,
              fast_moves: ["Vine Whip"],
              charged_moves: ["Frenzy Plant"],
            },
            {
              pokemon_id: 248,
              fast_moves: ["Smack Down"],
              charged_moves: ["Rock Wrecker"],
            },
          ],
        };

        // parse embedded exclusive moves
        const EXCLUSIVE = JSON.parse(
          document.getElementById("exclusive-moves").textContent
        );

        // state
        const state = {
          fast: [],
          charged: [],
          current: [],
          moveIndex: {},
          moveNamesCache: {},
          speciesNames: {},
          pokemonTypes: {},
        };

        // robust fetch
        async function getJSON(
          url,
          { timeout = 15000, retries = 2, backoff = 1.8 } = {}
        ) {
          let attempt = 0,
            lastErr;
          while (attempt <= retries) {
            const ctrl = new AbortController();
            const t = setTimeout(() => ctrl.abort(), timeout);
            try {
              const res = await fetch(url, {
                signal: ctrl.signal,
                cache: "no-cache",
              });
              clearTimeout(t);
              if (!res.ok) throw new Error(`HTTP ${res.status}`);
              return await res.json();
            } catch (e) {
              clearTimeout(t);
              lastErr = e;
              await new Promise((r) =>
                setTimeout(r, Math.pow(backoff, attempt) * 350)
              );
              attempt++;
            }
          }
          console.warn("getJSON failed", url, lastErr);
          return null;
        }

        // TTS
        let voiceReady = false;
        function loadVoicesOnce() {
          if (voiceReady) return;
          speechSynthesis.getVoices(); // kick
          speechSynthesis.onvoiceschanged = () => {
            voiceReady = true;
          };
          voiceReady = true; // best effort
        }
        function speakIcon(el, text, lang) {
          if (!("speechSynthesis" in window)) {
            alert("此瀏覽器不支援語音合成");
            return;
          }
          loadVoicesOnce();
          try {
            speechSynthesis.cancel();
          } catch {}
          const u = new SpeechSynthesisUtterance(text);
          u.lang = LANGS[lang] || lang || "en-US";
          const vs = speechSynthesis.getVoices();
          const v = vs.find((v) =>
            (v.lang || "")
              .toLowerCase()
              .startsWith((LANGS[lang] || "").toLowerCase())
          );
          if (v) u.voice = v;
          el.classList.add("playing");
          u.onend = u.oncancel = () => el.classList.remove("playing");
          speechSynthesis.speak(u);
        }

        // helpers
        const toSlug = (s) =>
          String(s)
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/(^-|-$)/g, "");
        const escapeHTML = (s) =>
          String(s).replace(
            /[&<>"']/g,
            (c) =>
              ({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              }[c])
          );
        const escapeAttr = (s) =>
          String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;");

        function inRegion(id, region) {
          if (region === "all") return true;
          const [a, b] = REGIONS[region];
          return id >= a && id <= b;
        }
        const EPS = (m) =>
          (m.energy_delta || 0) / ((m.duration || 1000) / 1000);
        const DPS = (m) => (m.power || 0) / ((m.duration || 1000) / 1000);

        // names (species) tri-lingual
        async function getSpeciesNames(id) {
          if (state.speciesNames[id]) return state.speciesNames[id];
          const res = await getJSON(POKE.species(id));
          if (!res) {
            const n = SPECIES_FALLBACK[id] || {
              en: "#" + id,
              zh: "#" + id,
              ja: "#" + id,
            };
            state.speciesNames[id] = n;
            return n;
          }
          const n = { en: "", zh: "", ja: "" };
          for (const x of res.names || []) {
            if (x.language.name === "en") n.en = x.name;
            if (x.language.name === "ja" || x.language.name === "ja-Hrkt")
              n.ja = x.name;
            if (x.language.name === "zh-Hant") n.zh = x.name;
          }
          if (!n.en) n.en = SPECIES_FALLBACK[id]?.en || "#" + id;
          if (!n.ja) n.ja = SPECIES_FALLBACK[id]?.ja || n.en;
          if (!n.zh) n.zh = SPECIES_FALLBACK[id]?.zh || n.en;
          state.speciesNames[id] = n;
          return n;
        }

        // pokemon types
        async function getPokemonTypes(id) {
          if (state.pokemonTypes[id]) return state.pokemonTypes[id];
          const res = await getJSON(POKE.pokemon(id));
          if (!res) {
            state.pokemonTypes[id] = [];
            return [];
          }
          const types = (res.types || [])
            .sort((a, b) => a.slot - b.slot)
            .map((t) => capitalize(t.type.name));
          state.pokemonTypes[id] = types;
          return types;
        }
        const capitalize = (s) =>
          s ? s.charAt(0).toUpperCase() + s.slice(1) : s;

        // move names tri-lingual (PoKeAPI) + fallback with exclusive JSON
        async function getMoveNames(enName) {
          if (state.moveNamesCache[enName]) return state.moveNamesCache[enName];
          // fallback from exclusive dict first (for GO-only names)
          const ex = EXCLUSIVE[enName];
          const base = {
            en: enName,
            zh: ex?.names?.zh || enName,
            ja: ex?.names?.ja || enName,
          };
          // try PokeAPI (most招式存在)
          const res = await getJSON(POKE.move(toSlug(enName)));
          if (!res) {
            state.moveNamesCache[enName] = base;
            return base;
          }
          const out = { ...base };
          for (const n of res.names || []) {
            if (n.language.name === "en") out.en = n.name;
            if (n.language.name === "ja" || n.language.name === "ja-Hrkt")
              out.ja = n.name;
            if (n.language.name === "zh-Hant") out.zh = n.name;
          }
          state.moveNamesCache[enName] = out;
          return out;
        }

        // loading
        async function loadAll() {
          loader.classList.add("active");
          try {
            let [fast, charged, current] = await Promise.all([
              getJSON(POGO.fast),
              getJSON(POGO.charged),
              getJSON(POGO.current),
            ]);

            if (
              !Array.isArray(fast) ||
              !Array.isArray(charged) ||
              !Array.isArray(current)
            ) {
              console.warn("API failed → using fallback mini dataset");
              fast = FALLBACK.fast;
              charged = FALLBACK.charged;
              current = FALLBACK.current;
            }

            // index moves by EN name
            const fIdx = Object.fromEntries(
              fast.map((m) => [m.name, { ...m, kind: "fast" }])
            );
            const cIdx = Object.fromEntries(
              charged.map((m) => [m.name, { ...m, kind: "charged" }])
            );
            state.moveIndex = { ...fIdx, ...cIdx };
            state.fast = fast;
            state.charged = charged;

            // 去重（以 pokemon_id），避免關都重複
            const seen = new Set();
            state.current = current.filter((x) => {
              if (seen.has(x.pokemon_id)) return false;
              seen.add(x.pokemon_id);
              return true;
            });
          } finally {
            loader.classList.remove("active");
            await render();
            selfTests();
          }
        }

        // region tag
        function dexRegion(id) {
          for (const [k, [a, b]] of Object.entries(REGIONS))
            if (id >= a && id <= b) return k[0].toUpperCase() + k.slice(1);
          return "—";
        }

        // type badge html
        const typeBadge = (t) =>
          `<span class="type ${escapeHTML(t)}">${escapeHTML(t)}</span>`;

        // move chip (for Top1 etc)
        function moveChip(move, metric, names, exTag) {
          const stat =
            metric === "eps"
              ? `${EPS(move).toFixed(2)} EPS`
              : `${DPS(move).toFixed(2)} DPS`;
          const t = move.type ? typeBadge(capitalize(move.type)) : "";
          return `<span class="pill">${t}
        <span>${escapeHTML(
          names.zh
        )}</span><span class="tts-ico" data-tts="${escapeAttr(
            names.zh
          )}" data-lang="zh">🔊</span>
        <span> / ${escapeHTML(
          names.en
        )}</span><span class="tts-ico" data-tts="${escapeAttr(
            names.en
          )}" data-lang="en">🔊</span>
        <span> / ${escapeHTML(
          names.ja
        )}</span><span class="tts-ico" data-tts="${escapeAttr(
            names.ja
          )}" data-lang="ja">🔊</span>
        <span class="stat">(${stat}${exTag ? "・限定" : ""})</span>
      </span>`;
        }

        // render
        let filtered = [];
        async function render() {
          const q = qInput.value.trim().toLowerCase();
          const region = regionSel.value;
          results.innerHTML = "";

          // region filter
          let list = state.current.filter((p) =>
            inRegion(p.pokemon_id, region)
          );

          // attach names and types first (for sort and display)
          await Promise.all(
            list.map(async (p) => {
              p.names = await getSpeciesNames(p.pokemon_id);
              p.types = await getPokemonTypes(p.pokemon_id);
            })
          );

          // query filter across names and moves (three languages for names; EN + translated for moves)
          if (q) {
            const out = [];
            for (const p of list) {
              const nameHit = [p.names.zh, p.names.en, p.names.ja].some((x) =>
                String(x).toLowerCase().includes(q)
              );
              let moveHit = false;
              if (!nameHit) {
                // EN list first
                const direct = (arr) =>
                  (arr || []).some((n) => String(n).toLowerCase().includes(q));
                moveHit = direct(p.fast_moves) || direct(p.charged_moves);
                if (!moveHit) {
                  // translated move names
                  const all = [
                    ...new Set([
                      ...(p.fast_moves || []),
                      ...(p.charged_moves || []),
                    ]),
                  ];
                  const tries = all.map(async (en) => {
                    const n = await getMoveNames(en);
                    return [n.zh, n.ja].some((t) =>
                      String(t).toLowerCase().includes(q)
                    );
                  });
                  try {
                    moveHit = await Promise.any(tries);
                  } catch {
                    moveHit = false;
                  }
                }
              }
              if (nameHit || moveHit) out.push(p);
            }
            list = out;
          }

          // sort: 預設一定照圖鑑編號，之後再依照選項覆蓋

          // ---------- 排序 ----------
          function sortList(list) {
            const key = sortSel.value;
            if (key === "id") {
              return list.sort(
                (a, b) => Number(a.pokemon_id) - Number(b.pokemon_id)
              );
            } else if (key === "name_en") {
              return list.sort((a, b) =>
                (a.names.en || "").localeCompare(b.names.en || "")
              );
            } else if (key === "name_zh") {
              return list.sort((a, b) =>
                (a.names.zh || "").localeCompare(b.names.zh || "")
              );
            } else if (key === "name_ja") {
              return list.sort((a, b) =>
                (a.names.ja || "").localeCompare(b.names.ja || "")
              );
            }
            return list;
          }
          // ⭐ 排序一定放在最後
          list = sortList(list);

          filtered = list;
          if (!list.length) {
            empty.style.display = "block";
            return;
          }
          empty.style.display = "none";
          // render in chunks
          const chunk = async (arr, size, fn) => {
            for (let i = 0; i < arr.length; i += size) {
              // 循序處理每個批次
              for (const item of arr.slice(i, i + size)) {
                await fn(item);
              }
            }
          };

          await chunk(list, 10, async (p) => {
            list.forEach((pokemon) => {
              console.log(pokemon.pokemon_id);
            });

            // compute Top1 fast by EPS, charged by DPS
            const fastObjs = (p.fast_moves || [])
              .map((n) => state.moveIndex[n])
              .filter(Boolean);
            const chargedObjs = (p.charged_moves || [])
              .map((n) => state.moveIndex[n])
              .filter(Boolean);
            const topFast = fastObjs.slice().sort((a, b) => EPS(b) - EPS(a))[0];
            const topCharged = chargedObjs
              .slice()
              .sort((a, b) => DPS(b) - DPS(a))[0];

            // figure exclusive moves for this pokemon
            const forcedFast = [],
              forcedCharged = [];
            for (const [en, def] of Object.entries(EXCLUSIVE)) {
              if (!def || !Array.isArray(def.pokemon_ids)) continue;
              if (def.pokemon_ids.includes(p.pokemon_id)) {
                if (def.category === "fast") forcedFast.push(en);
                if (def.category === "charged") forcedCharged.push(en);
              }
            }

            // preload names for moves that will appear (top1 + forced)
            const preload = [
              ...new Set([
                ...(topFast ? [topFast.name] : []),
                ...(topCharged ? [topCharged.name] : []),
                ...forcedFast,
                ...forcedCharged,
                ...(p.fast_moves || []),
                ...(p.charged_moves || []),
              ]),
            ];
            await Promise.all(preload.map(getMoveNames));

            const img = POKE.art(p.pokemon_id);
            const names = p.names;

            // build HTML
            const card = document.createElement("div");
            card.className = "card";
            card.innerHTML = `
          <div class="head">
            <div class="sprite">
              <img loading="lazy" src="${img}" alt="${escapeHTML(
              names.en
            )}" onerror="this.src=''; this.parentElement.textContent='No image'"/>
            </div>
            <div class="names">
              <div class="name-line">
                <span class="tag">中文</span>
                <span class="nm">${escapeHTML(names.zh)}</span>
                <span class="tts-ico" data-tts="${escapeAttr(
                  names.zh
                )}" data-lang="zh">🔊</span>
              </div>
              <div class="name-line">
                <span class="tag">EN</span>
                <span class="nm">${escapeHTML(names.en)}</span>
                <span class="tts-ico" data-tts="${escapeAttr(
                  names.en
                )}" data-lang="en">🔊</span>
              </div>
              <div class="name-line">
                <span class="tag">日文</span>
                <span class="nm">${escapeHTML(names.ja)}</span>
                <span class="tts-ico" data-tts="${escapeAttr(
                  names.ja
                )}" data-lang="ja">🔊</span>
              </div>

              <div class="region">
                <span class="badge">#${p.pokemon_id}</span>
                <span class="badge">${dexRegion(p.pokemon_id)}</span>
              </div>
              <div class="types">
                ${p.types.map(typeBadge).join("")}
              </div>
            </div>
          </div>

          <div class="body">
            <div><strong>小招：EPS Top1 + 限定</strong></div>
            <div class="chips" data-role="fast-chips"></div>
            <div style="margin-top:8px"><strong>大招：DPS Top1 + 限定</strong></div>
            <div class="chips" data-role="charged-chips"></div>
          </div>

          <details ${expandChk.checked ? "open" : ""}>
            <summary>展開招式對照表（三語 / 屬性 / EPS/DPS）</summary>
            ${movesTable(p)}
          </details>
        `;

            // fill chips
            const fastWrap = card.querySelector('[data-role="fast-chips"]');
            const chargedWrap = card.querySelector(
              '[data-role="charged-chips"]'
            );

            if (topFast) {
              const n = await getMoveNames(topFast.name);
              fastWrap.insertAdjacentHTML(
                "beforeend",
                moveChip(topFast, "eps", n, false)
              );
            }
            for (const en of forcedFast) {
              const base = state.moveIndex[en] || {
                name: en,
                duration: 1000,
                energy_delta: 7,
                power: 5,
                type: EXCLUSIVE[en]?.type || "Normal",
                kind: "fast",
              };
              const n = await getMoveNames(en);
              fastWrap.insertAdjacentHTML(
                "beforeend",
                moveChip(base, "eps", n, true)
              );
            }

            if (topCharged) {
              const n = await getMoveNames(topCharged.name);
              chargedWrap.insertAdjacentHTML(
                "beforeend",
                moveChip(topCharged, "dps", n, false)
              );
            }
            for (const en of forcedCharged) {
              const base = state.moveIndex[en] || {
                name: en,
                duration: 2600,
                energy_delta: -50,
                power: 100,
                type: EXCLUSIVE[en]?.type || "Normal",
                kind: "charged",
              };
              const n = await getMoveNames(en);
              chargedWrap.insertAdjacentHTML(
                "beforeend",
                moveChip(base, "dps", n, true)
              );
            }

            results.appendChild(card);
          });
        }

        // moves table
        function movesTable(p) {
          const all = [
            ...(p.fast_moves || []).map((n) => ({ name: n, kind: "fast" })),
            ...(p.charged_moves || []).map((n) => ({
              name: n,
              kind: "charged",
            })),
          ];
          // add exclusives (if not already in lists)
          for (const [en, def] of Object.entries(EXCLUSIVE)) {
            if (
              def.pokemon_ids.includes(p.pokemon_id) &&
              !all.find((x) => x.name === en)
            ) {
              all.push({ name: en, kind: def.category || "charged" });
            }
          }

          const rows = all
            .map((m) => {
              const stat = state.moveIndex[m.name] || {
                name: m.name,
                duration: 1000,
                energy_delta: m.kind === "fast" ? 8 : -50,
                power: m.kind === "fast" ? 7 : 100,
                type: EXCLUSIVE[m.name]?.type || "Normal",
                kind: m.kind,
              };
              const names = state.moveNamesCache[m.name] || {
                en: m.name,
                zh: m.name,
                ja: m.name,
              };
              const eps = m.kind === "fast" ? EPS(stat).toFixed(2) : "";
              const dps = m.kind === "charged" ? DPS(stat).toFixed(2) : "";
              const type = capitalize(
                stat.type || EXCLUSIVE[m.name]?.type || "Normal"
              );
              return `<tr>
          <td>${m.kind === "fast" ? "小招 Fast" : "大招 Charged"}</td>
          <td>${typeBadge(type)}</td>
          <td>${escapeHTML(
            names.zh
          )} <span class="tts-ico" data-tts="${escapeAttr(
                names.zh
              )}" data-lang="zh">🔊</span></td>
          <td>${escapeHTML(
            names.en
          )} <span class="tts-ico" data-tts="${escapeAttr(
                names.en
              )}" data-lang="en">🔊</span></td>
          <td>${escapeHTML(
            names.ja
          )} <span class="tts-ico" data-tts="${escapeAttr(
                names.ja
              )}" data-lang="ja">🔊</span></td>
          <td class="stat">${eps}</td>
          <td class="stat">${dps}</td>
        </tr>`;
            })
            .join("");

          return `<div style="overflow:auto">
        <table>
          <thead><tr><th>種類</th><th>屬性</th><th>中文</th><th>English</th><th>日本語</th><th>EPS</th><th>DPS</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
        }

        // events
        qInput.addEventListener("input", debounce(render, 250));
        regionSel.addEventListener("change", render);
        sortSel.addEventListener("change", render);
        expandChk.addEventListener("change", render);

        // delegate TTS (names & moves)
        results.addEventListener("click", (e) => {
          const btn = e.target.closest(".tts-ico[data-tts]");
          if (!btn) return;
          const lang = btn.dataset.lang;
          const text = btn.dataset.tts;
          speakIcon(btn, text, lang);
        });

        function debounce(fn, ms) {
          let t;
          return (...a) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...a), ms);
          };
        }

        // diag tests
        function selfTests() {
          const logs = [];
          const ok = (s) => logs.push("✅ " + s);
          const ng = (s) => logs.push("❌ " + s);
          try {
            const cards = $$(".card");
            if (cards.length) ok(`Rendered ${cards.length} card(s)`);
            else ng("No cards rendered");
            const tts = $$(".tts-ico").length;
            if (tts) ok(`Found ${tts} TTS icons`);
            else ng("No TTS icons");
          } catch (e) {
            ng("Self test error: " + e.message);
          }
          diag.textContent = logs.join("\n");
        }

        await loadAll();
      })();
    </script>
  </body>
</html>
